{"type":"settings","kernel":"python3","backend_state":"running","metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.4.3+"}},"kernel_state":"idle","trust":true}
{"input":"For the periodic cases, it's possible to find the solutions. The period-2 case is a situation where \n\n$$x_{n+2} \\ = \\  x_{n} $$\n\nBut\n\n$$ x_{n+1} \\ \\ne \\ x_{n}$$\n\n$$x_{n+2} \\ = \\ F(x_{n+1}) \\ = \\ F(F(x_{n})) \\ = \\ \\mu ^2 (1-x_{n}) x_{n} (\\mu  (x_{n}-1)\n   x_{n}+1) $$\n   \nWe have $x_{n+2} = x_{n} \\ne x_{n+1}$ for\n\n$$\nx \\ = \\ \\frac{1+\\mu \\pm\\sqrt{(\\mu -3) (\\mu\n   +1)}}{2 \\mu }\n$$\n\nWe can make a plot of the fixed-point solution and the period-2 solution. ","metadata":{"deletable":true,"editable":true},"pos":45,"collapsed":true,"cell_type":"markdown","type":"cell","id":"c6845a"}
{"type":"cell","id":"80b79d","pos":15,"input":"To see more, let's plot $x\\,(1-x)$ for $0<x<1$.","cell_type":"markdown"}
{"exec_count":8,"start":1497660548925,"input":"def show(mu,nmax,init):\n    x = iterate(mu,nmax,init).T\n    print('mu, 1-1/mu:',mu, 1-1/mu)\n    for i in range(x.shape[0]):\n        plt.plot(x[i])","state":"done","pos":23,"cell_type":"code","type":"cell","end":1497660548928,"id":"b47965","kernel":"python3"}
{"type":"cell","id":"f1c474","pos":51,"input":"And these become unstable to period-8 solutions and so on. Eventually the system becomes fully chaotic. ","cell_type":"markdown"}
{"type":"cell","id":"fda8d5","pos":55,"input":"Even thought this is has an exact solution, eventually it becomes impossible to follow it exactly. Small roundoff errors lead to the computed solution and the exact solution to diverge.","cell_type":"markdown"}
{"type":"cell","id":"64b265","pos":26,"input":"**TASK 7:** Make sure to analyse a lot of different cases in the range $1< \\mu \\le 4$.","cell_type":"markdown"}
{"output":{"0":{"text":"mu, 1-1/mu: 4 0.75\n","name":"stdout"},"1":{"data":{"image/png":"f6802e8f24c267697164ff42a55c292be16083a2"}}},"exec_count":18,"start":1497660602725,"input":"show(4,200,[0.3,0.3000001])","state":"done","pos":41,"cell_type":"code","type":"cell","end":1497660603133,"id":"25af6c","kernel":"python3"}
{"exec_count":2,"start":1497658678987,"input":"def f(x,mu):\n    return np.abs(mu/(mu-1) - 1/x)**(1/(mu-1))","state":"done","pos":5,"cell_type":"code","type":"cell","end":1497658678989,"id":"f88ab0","kernel":"python3"}
{"output":{"0":{"text":"mu, 1-1/mu: 4 0.75\n","name":"stdout"},"1":{"data":{"image/png":"cc0b24dad8458f7778c8160b21cb83eaf5522700"}}},"exec_count":24,"start":1497660681927,"input":"a = 0.3\nshow(4,100,[a])\nx = iterate(4,100,[a]).T[0]","state":"done","pos":54,"cell_type":"code","type":"cell","end":1497660682234,"id":"c04002","kernel":"python3"}
{"output":{"0":{"text":"mu, 1-1/mu: 2.6 0.6153846153846154\n","name":"stdout"},"1":{"data":{"image/png":"9e6d4a177c894dab731e2ac0974baf8e1f59d819"}}},"exec_count":10,"start":1497660554629,"input":"show(2.6,20,init)","state":"done","pos":28,"cell_type":"code","type":"cell","end":1497660555030,"id":"d9bfb0","kernel":"python3"}
{"output":{"0":{"text":"mu, 1-1/mu: 3.44948974278 0.710102051443\n","name":"stdout"},"1":{"data":{"image/png":"670a770ab2132992c46a76689faaaa0540ba620b"}}},"exec_count":23,"start":1497660664827,"input":"show(1+np.sqrt(6),30,[0.3])","state":"done","pos":50,"cell_type":"code","type":"cell","end":1497660665133,"id":"0121bd","kernel":"python3"}
{"type":"cell","id":"de8b51","pos":20,"input":"We can see that the solution is converging to the predicted value for $1<\\mu<3$.","cell_type":"markdown"}
{"output":{"0":{"text":"/usr/local/lib/python3.4/dist-packages/ipykernel/__main__.py:3: RuntimeWarning: invalid value encountered in sqrt\n  app.launch_new_instance()\n/usr/local/lib/python3.4/dist-packages/ipykernel/__main__.py:4: RuntimeWarning: invalid value encountered in sqrt\n","name":"stderr"},"1":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7f24bd373fd0>]"},"exec_count":20},"2":{"data":{"image/png":"bc530c1fa311059f7d88ca71dee5e994e3afcdde"}}},"exec_count":20,"start":1497660636289,"input":"mu = np.linspace(1,4,100)\nx0 = 1-1/mu\nxp = 0.5*( (1+mu) + np.sqrt(mu-3)*(mu+1))/mu\nxm = 0.5*( (1+mu) - np.sqrt(mu-3)*(mu+1))/mu\nplt.plot(mu,x0,color='orange')\nplt.plot(mu,xp.real,color='blue')\nplt.plot(mu,xm.real,color='green')","state":"done","pos":46,"cell_type":"code","type":"cell","end":1497660636664,"id":"34b075","kernel":"python3"}
{"type":"file","last_load":1497658287266}
{"type":"cell","id":"424de9","pos":53,"input":"The case $\\mu=4$ seem particularly chaotic. And it is. Any two initial conditions will diverge from eachother exponentially fast. But there is a suprising order in this particular case. \n\nAssume \n\n$$ x_{n} \\ = \\ \\sin^{2}(\\theta_{n}) $$\n\nFor $0 \\le \\theta_{n} < 2 \\pi$.\n\nFor $\\mu=4$, \n\n$$\n\\sin^{2}(\\theta_{n+1}) \\ = \\ 4 \\sin^{2}(\\theta_{n}) (1- \\sin^{2}(\\theta_{n})) \\ = \\ 4 \\sin^{2}(\\theta_{n}) \\cos^{2}(\\theta_{n}) \\ = \\ \\sin^{2}(2\\theta_{n})\n$$\n\nThefore, \n$$\n\\theta_{n+1} \\ = 2 \\theta_{n}\n$$\nIt doesn't get much simpler. \n$$\n\\theta_{n} \\ = \\ 2^{n} \\theta_{0}\n$$\nOr \n$$\nx_{n} \\ = \\ \\sin^{2}\\left(2^{n} \\arcsin\\left(\\sqrt{x_0}\\right\n   )\\right)\n$$\n\nIt seems we've just found an exact solution in the most chaotic case. This is a very rare thing. There is no such luck for the other values of $\\mu$. At least not that anyone knows about. \n\nBut it doesn't mean we can't compute things easily.","cell_type":"markdown"}
{"type":"cell","id":"963b74","pos":14,"input":"**TAKS 4:** What happens for $\\mu > 4$? What does this mean for shape of the original function $f(x)$? ","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"output":{"0":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7f24c10e05c0>]"},"exec_count":4},"1":{"data":{"image/png":"326e3818f73c9d2bd6be8e57f7236452a7c00029"}}},"exec_count":4,"start":1497660532613,"input":"mu = np.linspace(1,4,100)\nplt.plot(mu,abs(2-mu))\nplt.plot(mu,1 + 0*mu)","state":"done","pos":12,"cell_type":"code","type":"cell","end":1497660532954,"id":"4e79b7","kernel":"python3"}
{"output":{"0":{"text":"mu, 1-1/mu: 3.94 0.7461928934010152\n","name":"stdout"},"1":{"data":{"image/png":"3edd04a3498b3ef3f3f0c0ce268c4423ecb09138"}}},"exec_count":16,"start":1497660591825,"input":"show(3.94,100,[0.3,0.7])","state":"done","pos":38,"cell_type":"code","type":"cell","end":1497660592152,"id":"724099","kernel":"python3"}
{"type":"cell","id":"d0e63f","pos":39,"input":"For $\\mu=4$ it looks very messy. The system also has ***sensitive dependence on initial conditions***. Two iterations that start almost at the same point, eventally wander away from eachother. ","cell_type":"markdown"}
{"type":"cell","id":"269df7","pos":0,"input":"## Tutorial 02: The logistics of iteration","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"output":{"0":{"text":"1-1/mu, x[nmax] : 0.6 [ 0.6  0.6  0.6  0.6  0.6]\n","name":"stdout"}},"exec_count":7,"start":1497660546625,"input":"mu, nmax, init = 2.5, 42, [0.2,0.3,0.4,0.5,0.6]\n\nx = iterate(mu,nmax,init)\n\nprint('1-1/mu, x[nmax] :',1-1/mu, x[-1])","state":"done","pos":21,"cell_type":"code","type":"cell","end":1497660546636,"id":"0a0206","kernel":"python3"}
{"type":"cell","id":"ef2449","pos":57,"input":"","cell_type":"code","collapsed":true}
{"type":"cell","id":"f31d51","pos":52,"input":"# $\\mu=4$","cell_type":"markdown"}
{"output":{"0":{"text":"mu, 1-1/mu: 3 0.6666666666666667\n","name":"stdout"},"1":{"data":{"image/png":"478e6869d4b531d139dd9206d0bd3526be0f847c"}}},"exec_count":22,"start":1497660661148,"input":"show(3,30,[0.3])","state":"done","pos":48,"cell_type":"code","type":"cell","end":1497660661628,"id":"3d2656","kernel":"python3"}
{"output":{"0":{"text":"mu, 1-1/mu: 3.1 0.6774193548387097\n","name":"stdout"},"1":{"data":{"image/png":"e10c252bebe9cbcb8ee6dd08bd571e62ab07b829"}}},"exec_count":13,"start":1497660569453,"input":"show(3.1,30,init)","state":"done","pos":34,"cell_type":"code","type":"cell","end":1497660569830,"id":"c512fe","kernel":"python3"}
{"output":{"0":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7f24c10dc668>]"},"exec_count":25},"1":{"data":{"image/png":"4f6c4d84b891eff6ffb4e1790b36804b05fa9312"}}},"exec_count":25,"start":1497660688798,"input":"n = np.arange(0,len(x),1)\nerror = np.abs(x-np.sin(2**(n)*np.arcsin(np.sqrt(x[0])))**2)\nplt.semilogy(error)","state":"done","pos":56,"cell_type":"code","type":"cell","end":1497660689727,"id":"11fd81","kernel":"python3"}
{"type":"cell","id":"95f00a","pos":10,"input":"**TASK 3:** Show that $x^*$ is a fixed point of $F(x)$ and analyse the stability as a function of $\\mu$. What does the stability say for using Newton's method to converge to the fixed point from an inital guess?","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"type":"cell","id":"179880","pos":47,"input":"We can see the system *bifurcates* at $\\mu=3$. The orange solution still is possible, but it's ***unstable***.\n\n\nAt some other value of $\\mu$ the period-2 solutions will become unstable to period-4 solutions. \n\nThe period-2 solution becomes unstable at\n\n$$\\mu \\ = \\ 1 + \\sqrt{6} \\ \\approx \\ 3.44949 $$\n","cell_type":"markdown"}
{"type":"cell","id":"67d9df","pos":4,"input":"**TASK 0:** Make a Python function that evaluates this function for different values of $x$ for $\\mu>1$. ","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"type":"cell","id":"63e5b2","pos":27,"input":"This should still converge, but slower...","cell_type":"markdown"}
{"type":"cell","id":"605868","pos":13,"input":"We can see that the system is stable for $1< \\mu < 3$. For these values the Netwon iteration should converge to the solution for the original function $f(x) = 0$. \n\nFor $\\mu > 3$ the result should do something else. Exactly what it does remains a question.\n\n","cell_type":"markdown"}
{"output":{"0":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7f24bef73cc0>]"},"exec_count":5},"1":{"data":{"image/png":"c9f060bbae1d2065a2c14f05cc497b15a728187e"}}},"exec_count":5,"start":1497660539825,"input":"x = np.linspace(0,1,200)\nplt.plot(x,x*(1-x))","state":"done","pos":16,"cell_type":"code","type":"cell","end":1497660540143,"id":"124ed3","kernel":"python3"}
{"type":"cell","id":"56843e","pos":11,"input":"**SOLUTION**\n\nSolve for a fixed point of the iteration: \n\n$$ x^{*} = \\mu \\, x^{*} (1 - x^{*} ) $$\n\nEither \n\n$$x^{*} = 0$$\n\nor \n\n$$ \\mu (1-x^{*}) = 1 ,\\quad \\implies \\quad x^{*} \\ = \\ \\frac{\\mu-1}{\\mu} \\ = \\ 1 - \\frac{1}{\\mu}$$\n\nThe first case is not a valid point for the original function $f(x)$. The solution is the value of the root of the original function. That is, $f(x^*) = 0$.\n\n**STABILITY**\n\nWe want to see what happens for values near the fixed point. Therefore, we assume \n\n$$x_{n} \\ = \\ \\frac{\\mu-1}{\\mu} + \\delta_{n}$$\n\nFor small $\\delta_{n}$ \n\n$$\n\\delta_{n+1} \\ \\approx \\ (\\mu-2) \\delta_{n}  \n$$\n\nTherefore \n\n$$\n\\delta_{n} \\ \\approx \\ (2-\\mu)^{n} \\delta_{0}\n$$\n\nTherefore \n\n$$\n\\lim_{n\\to \\infty} |\\delta_{n}| \\ = \\ 0 , \\quad \\mathrm{if} \\quad |\\, \\mu - 2 \\, | < 1\n$$\nOtherwise $\\delta_{n}$ will grow in magnitue with each iteration and $x_{n}$ will not converge to $x^{*}$.\n","cell_type":"markdown"}
{"type":"cell","id":"d01b63","pos":9,"input":"$$ \\frac{f'(x)}{f(x)} \\ = \\ \\frac{1}{\\mu-1}\\frac{d}{dx} \\log\\left( \\frac{\\mu}{\\mu-1} - \\frac{1}{x}\\right) \\ = \\ \\frac{1}{\\mu-1}\\frac{d}{dx}\\left[ \\log\\left( \\frac{\\mu x }{\\mu-1} - 1 \\right) - \\log x \\right]$$\n\n$$ \\frac{f'(x)}{f(x)} \\ = \\ \\frac{1}{\\mu-1}\\left[ \\frac{\\frac{\\mu}{\\mu-1}}{\\frac{\\mu x }{\\mu-1} - 1 } - \\frac{1}{x} \\right] \\ = \\ \\frac{1}{x-\\mu  (1-x) x}$$\n\n$$F(x) \\ = \\ x - \\frac{f(x)}{f'(x)} \\ = \\ \\mu  (1-x) x$$\n\nThe itration \n\n$$ x_{n+1} \\ = \\ \\mu\\, x_{n}(1-x_{n}) $$\n\nThis is called the *Logistic* map. It arises in a number of settings. This map produces some very interesting dynamics and teaches us a lot about the potential complexity of iteration.","cell_type":"markdown"}
{"output":{"0":{"text":"mu, 1-1/mu: 3.2 0.6875\n","name":"stdout"},"1":{"data":{"image/png":"6ba1ceb61461303c5d275f473953d1bf63b484a9"}}},"exec_count":14,"start":1497660576325,"input":"show(3.2,30,init)","state":"done","pos":35,"cell_type":"code","type":"cell","end":1497660576648,"id":"1948b7","kernel":"python3"}
{"type":"cell","id":"85717a","pos":37,"input":"For some value of $\\mu$ the system becomes ***chaotic***. The solution never settles down into a periodic solution. ","cell_type":"markdown"}
{"output":{"0":{"text":"mu, 1-1/mu: 3 0.6666666666666667\n","name":"stdout"},"1":{"data":{"image/png":"0d0434478ca906020f1b7dbb9e779538d239a2ac"}}},"exec_count":12,"start":1497660562530,"input":"show(3,30,init)","state":"done","pos":32,"cell_type":"code","type":"cell","end":1497660562843,"id":"e046d0","kernel":"python3"}
{"output":{"0":{"text":"mu, 1-1/mu: 2.95 0.6610169491525424\n","name":"stdout"},"1":{"data":{"image/png":"fab51d23639aa6ba6bcd4bc8112b4d697ffb836f"}}},"exec_count":11,"start":1497660557925,"input":"show(2.95,60,init)","state":"done","pos":30,"cell_type":"code","type":"cell","end":1497660558242,"id":"4cd874","kernel":"python3"}
{"type":"cell","id":"5c5891","pos":24,"input":"This should converge fast","cell_type":"markdown"}
{"output":{"0":{"text":"mu : [ 2.  3.  4.  5.  6.  7.]\n","name":"stdout"},"1":{"data":{"image/png":"029d89a68d90cf8bdb124fccc015c119525c3279"}}},"exec_count":3,"start":1497658681572,"input":"x  = np.linspace(0.1,1,500)\nmu = np.arange(2,7.5,1)\nprint(\"mu :\", mu)\n\ncolors = ['blue','green','orange','black','red','purple']\n\nfor k in range(len(mu)):\n    plt.plot(x,f(x,mu[k]),color=colors[k])","state":"done","pos":7,"cell_type":"code","type":"cell","end":1497658681845,"id":"23ec5a","kernel":"python3"}
{"output":{"0":{"text":"[  2.00000000e-001   6.88000000e-001   9.23020800e-001   3.05529632e-001\n   9.12379487e-001   3.43755584e-001   9.70027035e-001   1.25020722e-001\n   4.70379326e-001   1.07122725e+000  -3.28092444e-001  -1.87366951e+000\n  -2.31525198e+001  -2.40452429e+003  -2.48718088e+007  -2.66000966e+015\n  -3.04253010e+031  -3.98050545e+063  -6.81310218e+127  -1.99598953e+256\n              -inf              -inf              -inf]\n","name":"stdout"},"1":{"text":"/usr/local/lib/python3.4/dist-packages/ipykernel/__main__.py:2: RuntimeWarning: overflow encountered in multiply\n  from ipykernel import kernelapp as app\n","name":"stderr"}},"exec_count":19,"start":1497660606709,"input":"print((iterate(4.3,23,[0.2]).T)[0])","state":"done","pos":43,"cell_type":"code","type":"cell","end":1497660606718,"id":"df6177","kernel":"python3"}
{"type":"cell","id":"435258","pos":49,"input":"Now it takes 4 iterations to get back to the same value.","cell_type":"markdown"}
{"type":"cell","id":"a8d104","pos":3,"input":"To have some fun, let's try to use Newton's method to solve for the root of the \"pathological\" example\n\n$$\nf(x) \\ = \\ \\left| \\frac{\\mu}{\\mu-1} - \\frac{1}{x}\\right|^{\\tfrac{1}{\\mu-1}},\n$$\n\nwhere $\\mu > 1$. \nThis continuous function has a root at $x^{*} = 1 - 1/\\mu$. I.e., \n$$\nf(x^*) = 0\n$$\n\n\nBecause $\\mu>1$, $1>x^{*}> 0$.   \n\nThe function is not differentiable at the location of the root. But we do have $f'(x^*) \\ne 0$. Quite the opposite, actually. This will break some of the nice theory surrounding Newton's method.  But this \"pathological\" example is not that uncommon in real life. Especially in higher dimensions. And even if you know you have a differentiable function, it's common to get function that look \"cupsy\" like this one. \n","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"exec_count":6,"start":1497660544058,"input":"def F(x,mu):\n    return mu*x*(1-x)\n\ndef iterate(mu,n_iterations,initial_values):\n    x = np.zeros((n_iterations,len(initial_values)))\n    x[0] = initial_values\n    for i in range(1,n_iterations):\n        x[i] = F(x[i-1],mu)\n    return x","state":"done","pos":19,"cell_type":"code","type":"cell","end":1497660544128,"id":"38bd6d","kernel":"python3"}
{"type":"cell","id":"9909b2","pos":33,"input":"It gets's better","cell_type":"markdown"}
{"type":"cell","id":"e7489d","pos":2,"input":"**Remember:** \n\nThe $\\boldsymbol{+}$ button adds a cell\n\nThe $\\boldsymbol{\\circlearrowright}$ button quits the kernal\n\nThe menue to the right of the $\\boldsymbol{\\circlearrowright}$ changes a cell from Python \"`Code`\" to \"`Markdown`\"\n\nDouble clicking on a `Markdown` cell shows the contents and allows you to edit it\n\nAnd `Shift Enter` evaluates a cell.","cell_type":"markdown"}
{"type":"cell","id":"b2849a","pos":8,"input":"**TASK 2:** Compute the Newton iteration function $F(x) = x - f(x)/f'(x)$.","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"type":"cell","id":"1dd67d","pos":6,"input":"**TASK 1**: Plot this function on the domain $1>x>0$ for different values of $\\mu$. Describe what you expect regarding how Newton's method might behave.","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"type":"cell","id":"f99dac","pos":31,"input":"For $\\mu=3$ things really change... It becomes periodic. There is a ***bifurcation*** in the behaviour. Rather than *one* fixed point, the system oscilates around *two* points.","cell_type":"markdown"}
{"type":"cell","id":"ffa1ad","pos":29,"input":"We can see things converging slower as we get to the cirtical value of $\\mu = 3$... ","cell_type":"markdown"}
{"output":{"0":{"text":"mu, 1-1/mu: 3.5 0.7142857142857143\n","name":"stdout"},"1":{"data":{"image/png":"63433caad0df0107cbf707e8a83c04b94fdf9013"}}},"exec_count":15,"start":1497660582378,"input":"show(3.5,30,[0.3,0.7])","state":"done","pos":36,"cell_type":"code","type":"cell","end":1497660582736,"id":"fce132","kernel":"python3"}
{"output":{"0":{"text":"mu, 1-1/mu: 4 0.75\n","name":"stdout"},"1":{"data":{"image/png":"d75cd251a5a9591637332bdac9caae92d30f92e6"}}},"exec_count":17,"start":1497660598529,"input":"show(4,50,[0.3,0.3000001])","state":"done","pos":40,"cell_type":"code","type":"cell","end":1497660598856,"id":"497bee","kernel":"python3"}
{"type":"cell","id":"933adc","pos":17,"input":"We can see that \n\n$$0 < F(x) < \\frac{\\mu}{4}$$\n\nFor $0<x<1$. This means that for $\\mu<4$\n\n$$0 < x_{n} < 1 \\quad \\implies \\quad 0 < x_{n+1} < 1$$. \n\nThings don't wander away. But for $\\mu>4$ points will eventually leave the comfort of $0<x<1$ and wander away to $\\infty$.\n\nFor the shape of the original function $f(x)$, this means that the solve is getting very shallow, so that $1/f'(x)$ is getting large. This shoots things off to large values of $x$. ","cell_type":"markdown"}
{"type":"cell","id":"3bbc23","pos":22,"input":"**TASK 6** Make a plot of $x$ as a function of the iteration number, $n$. Do this for different values of $\\mu$. What's happening? ","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"output":{"0":{"text":"mu, 1-1/mu: 2.0 0.5\n","name":"stdout"},"1":{"data":{"image/png":"e82672ada6b5d79d59241774523993850846d9f4"}}},"exec_count":9,"start":1497660550640,"input":"show(2.0,20,init)","state":"done","pos":25,"cell_type":"code","type":"cell","end":1497660551048,"id":"8e5965","kernel":"python3"}
{"type":"cell","id":"59ad35","pos":44,"input":"**TASK 8:** Can you find a mathematical function that gives me $x_{n}$ for any $n$, any starting guess, and some value of $\\mu$? Don't work too long on this task. The idea is that these functions might very well exist. But no one's found very many. We don't know if this system is irreducibly complex or not. ","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"exec_count":1,"start":1497658676926,"input":"# These are some of the modules that you'll likely need. \n# I'll put them here this time. \n#In the furture, I'll expect you to figure out whaat you need.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline","state":"done","pos":1,"cell_type":"code","type":"cell","end":1497658676930,"id":"23d28c","kernel":"python3"}
{"type":"cell","id":"e94b5d","pos":18,"input":"**TASK 5:** Make a Python function that preforms the Newton iteration from an initial guess; or range of guesses. This time you'll want to keep track of the guesses. Output the results in a numpy array. You can use a `functional` method or a `procedural` method; which ever you think is best for the situation. ","cell_type":"markdown","metadata":{"deletable":true,"editable":true}}
{"type":"cell","id":"7e3f28","pos":42,"input":"For $\\mu > 4$, we predicted the dynamics would run away to $\\infty$. ","cell_type":"markdown"}